<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>如何把View Controller瘦下来！ | 王绵杰的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="如何把View Controller瘦下来
有时候View Controller由于做了太多的事情，而变得非常庞大。这里既有数据的收集，又有逻辑的处理，还有各种归属于该View Controller的控件内存分配。这里面哪些可以代理到其他模块呢？这篇博客就是探索项目的架构，目的是分离复杂的代码逻辑，让我们的代码可读性更强。
在View Controller里，这些职责或许是被各种 #pragma">
<meta property="og:type" content="article">
<meta property="og:title" content="如何把View Controller瘦下来！">
<meta property="og:url" content="http://thornvbear.com/2016/08/18/如何把ViewController瘦下来/index.html">
<meta property="og:site_name" content="王绵杰的个人博客">
<meta property="og:description" content="如何把View Controller瘦下来
有时候View Controller由于做了太多的事情，而变得非常庞大。这里既有数据的收集，又有逻辑的处理，还有各种归属于该View Controller的控件内存分配。这里面哪些可以代理到其他模块呢？这篇博客就是探索项目的架构，目的是分离复杂的代码逻辑，让我们的代码可读性更强。
在View Controller里，这些职责或许是被各种 #pragma">
<meta property="og:updated_time" content="2016-08-25T15:58:48.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="如何把View Controller瘦下来！">
<meta name="twitter:description" content="如何把View Controller瘦下来
有时候View Controller由于做了太多的事情，而变得非常庞大。这里既有数据的收集，又有逻辑的处理，还有各种归属于该View Controller的控件内存分配。这里面哪些可以代理到其他模块呢？这篇博客就是探索项目的架构，目的是分离复杂的代码逻辑，让我们的代码可读性更强。
在View Controller里，这些职责或许是被各种 #pragma">
  
    <link rel="alternate" href="/atom.xml" title="王绵杰的个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">王绵杰的个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">STAY HUNGRY ！ STAY FOOLISH ！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://thornvbear.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-如何把ViewController瘦下来" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/18/如何把ViewController瘦下来/" class="article-date">
  <time datetime="2016-08-18T14:49:38.000Z" itemprop="datePublished">2016-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      如何把View Controller瘦下来！
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="如何把View-Controller瘦下来"><a href="#如何把View-Controller瘦下来" class="headerlink" title="如何把View Controller瘦下来"></a>如何把View Controller瘦下来</h1><ul>
<li>有时候View Controller由于做了太多的事情，而变得非常庞大。这里既有数据的收集，又有逻辑的处理，还有各种归属于该View Controller的控件内存分配。这里面哪些可以代理到其他模块呢？这篇博客就是探索项目的架构，目的是分离复杂的代码逻辑，让我们的代码可读性更强。</li>
<li>在View Controller里，这些职责或许是被各种 <code>#pragma mark</code> 分组实现，如果你是这样的话，那么就可以考虑把这些部分拆分到不同的文件里。</li>
</ul>
<h1 id="Data-Source"><a href="#Data-Source" class="headerlink" title="Data Source"></a>Data Source</h1><ul>
<li>Data Source的方式是一种拆离View Controller里数据显示逻辑的方式，尤其是在一些复杂的table views里，这种方式可以有效地从View Controller里分离所有cells的数据显示逻辑。</li>
<li><p>Data Source对象可以遵守<code>UITableViewDataSource</code>协议，以实现数据的显示，但是我发现使用这些对象配置cells是一件可以独立出来的逻辑，所以可以把这部分逻辑也独立出来。下面一个很简单的例子：</p>
<pre><code>@implementation TBSectionedDataSource : NSObject

- (instancetype)initWithObjects:(NSArray *)objects sectioningKey:(NSString *)sectioningKey {
    self = [super init];
    if (!self) return nil;

    [self sectionObjects:objects withKey:sectioningKey];

    return self;
}

- (void)sectionObjects:(NSArray *)objects withKey:(NSString *)sectioningKey {
    self.sectionedObjects = objects //section the objects array
}

- (NSUInteger)numberOfSections {
    return self.sectionedObjects.count;
}

- (NSUInteger)numberOfObjectsInSection:(NSUInteger)section {
    return [self.sectionedObjects[section] count];
}

- (id)objectAtIndexPath:(NSIndexPath *)indexPath {
    return self.sectionedObjects[indexPath.section][indexPath.row];
}

@end
</code></pre></li>
<li><p>这种data source的设计是为了抽象和重用，不要担心你的类仅仅在一个地方使用。从view controller里分离数据显示逻辑是一种管理懒加载的方式。特别是针对一个动态table views来说，这种方式很适合view controller来管理显示数据。</p>
</li>
<li>这种方式也可以管理你的重用逻辑。在这里可以获取服务器端的数据，从而把网络访问模块给分离出去。</li>
<li>如果你的界面是静态的话，那么你可以定制一个data source类用来专门显示这一块。在多个data source的情况下，每一个data source的子类都可以在自己的section里显示。</li>
<li>使用这种方式可以避免很多事情，把数据逻辑拆分的同时还可以把网络访问模块拆出来。</li>
</ul>
<h1 id="Standard-Composition"><a href="#Standard-Composition" class="headerlink" title="Standard Composition"></a>Standard Composition</h1><ul>
<li>这个可以理解为标准化组合，多个View Controller可以使用View Controller容器管理起来，如果你的view controller由多个逻辑单元组成，那么可以把这种复杂的逻辑拆分到多个view controller中。经验表明这种方式适合一个界面有多个table view或者是多个collection view的情况。</li>
<li><p>比如在一个界面上包含一个header和一个网格类型的视图，那么我们可以使用懒加载的方式加载这两个view controller，当系统用到的时候再去加载资源。</p>
<pre><code>- (TBHeaderViewController *)headerViewController {
    if (!_headerViewController) {
        TBHeaderViewController *headerViewController = [[TBHeaderViewController alloc] init];
          [self addChildViewController:headerViewController];
        [headerViewController didMoveToParentViewController:self];

        [self.view addSubview:headerViewController.view];

        self.headerViewController = headerViewController;
        }
        return _headerViewController;
}

- (TBGridViewController *)gridViewController {
    if (!_gridViewController) {
           TBGridViewController *gridViewController = [[TBGridViewController alloc] init];

        [self addChildViewController:gridViewController];
        [gridViewController didMoveToParentViewController:self];

        [self.view addSubview:gridViewController.view];

        self.gridViewController = gridViewController;
    }
    return _gridViewController;
}

- (void)viewDidLayoutSubviews {
    [super viewDidLayoutSubviews];

    CGRect workingRect = self.view.bounds;

    CGRect headerRect = CGRectZero, gridRect = CGRectZero;
    CGRectDivide(workingRect, &amp;headerRect, &amp;gridRect, 44, CGRectMinYEdge);

    self.headerViewController.view.frame = tagHeaderRect;
    self.gridViewController.view.frame = hotSongsGridRect;
}
</code></pre></li>
<li><p>在结果子视图里，其包含的每个collection view，都展示统一的数据类型，这样更便于管理和修改。</p>
<h1 id="Smarter-Views"><a href="#Smarter-Views" class="headerlink" title="Smarter Views"></a>Smarter Views</h1></li>
<li><p>如果你是在view controller类初始化你所有的子视图的话，那么你应该考虑使用更适合自己的View。UIViewController默认使用UIView，不过同样你可以自定义View实现重写。使用<code>-loadView</code>来达到这种效果，在这里你只需要把自定义的View设置给<code>self.view</code>即可。</p>
<pre><code>@implementation TBProfileViewController

- (void)loadView {
    self.view = [[TBProfileView alloc] init];
}

//...

@end

@implementation TBProfileView : NSObject

- (UILabel *)nameLabel {
    if (!_nameLabel) {
        UILabel *nameLabel = [[UILabel alloc] init];
        //configure font, color, etc
        [self addSubview:nameLabel];
            self.nameLabel = nameLabel;
    }
    return _nameLabel;
}

- (UIImageView *)avatarImageView {
    if (!_avatarImageView) {
        UIImageView * avatarImageView = [UIImageView new];
        [self addSubview:avatarImageView];
        self.avatarImageView = avatarImageView;
    }
    return _avatarImageView
}

- (void)layoutSubviews {
    //perform layout
}

@end
</code></pre><h1 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h1></li>
<li>Presenter（一系列get方法）是从Model中获取数据并提供给View层，Presenter还负责处理后台任务</li>
<li>主导器一般包含着model对象，这里的model是用来展示的，所以属性都是暴露出来的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@implementation TBUserPresenter : NSObject</div><div class="line"></div><div class="line">- (instancetype)initWithUser:(TBUser *)user &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) return nil;</div><div class="line">    _user = user;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)name &#123;</div><div class="line">    return self.user.name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)followerCountString &#123;</div><div class="line">    if (self.user.followerCount == 0) &#123;</div><div class="line">        return @&quot;&quot;;</div><div class="line">    &#125;</div><div class="line">    return [NSString stringWithFormat:@&quot;%@ followers&quot;, [NSNumberFormatter localizedStringFromNumber:@(_user.followerCount) numberStyle:NSNumberFormatterDecimalStyle]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)followersString &#123;</div><div class="line">    NSMutableString *followersString = [@&quot;Followed by &quot; mutableCopy];</div><div class="line">    [followersString appendString:[self.class.arrayFormatter stringFromArray:[self.user.topFollowers valueForKey:@&quot;name&quot;]];</div><div class="line">    return followersString;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (TTTArrayFormatter*) arrayFormatter &#123;</div><div class="line">    static TTTArrayFormatter *_arrayFormatter;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _arrayFormatter = [[TTTArrayFormatter alloc] init];</div><div class="line">        _arrayFormatter.usesAbbreviatedConjunction = YES;</div><div class="line">    &#125;);</div><div class="line">    return _arrayFormatter;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li>需要注意的一点是，model对象本身是不暴露出去的。Presenter作为model的看门人，保证了view controller不用避开主逻辑服务，而可以直接访问model层。这种架构减少了依赖性，由于 <code>TBUser</code> 的存在，使得model接触的类比较少，因此如果它改变，则牵涉的逻辑比较少。</li>
</ul>
<h1 id="Binding-pattern"><a href="#Binding-pattern" class="headerlink" title="Binding pattern"></a>Binding pattern</h1><ul>
<li>在形式上，这种可以看做<code>-configureView</code>。当数据层发生改变的时候捆绑形式就会更新view。Cocoa本身就适合这个，因为KVO可以检测到model层的变动，而KVC可以从model层读取数据然后赋给view，两者实现完美结合。第三方库Reactive Cocoa也是采用了这种方式，但它有点太庞大。</li>
<li>这种方式与主导器结合起来效果非常好，一个创建对象来传递值，而另一个去接受然后显示到view上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@implementation TBProfileBinding : NSObject</div><div class="line"></div><div class="line">- (instancetype)initWithView:(TBProfileView *)view presenter:(TBUserPresenter *)presenter &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) return nil;</div><div class="line">    _view = view;</div><div class="line">    _presenter = presenter;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSDictionary *)bindings &#123;</div><div class="line">    return @&#123;</div><div class="line">              @&quot;name&quot;: @&quot;nameLabel.text&quot;,</div><div class="line">              @&quot;followerCountString&quot;: @&quot;followerCountLabel.text&quot;,</div><div class="line">            &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)updateView &#123;</div><div class="line">    [self.bindings enumerateKeysAndObjectsUsingBlock:^(id presenterKeyPath, id viewKeyPath, BOOL *stop) &#123;</div><div class="line">        id newValue = [self.presenter valueForKeyPath:presenterKeyPath];</div><div class="line">        [self.view setObject:newvalue forKeyPath:viewKeyPath];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h1 id="interaction-pattern"><a href="#interaction-pattern" class="headerlink" title="interaction pattern"></a>interaction pattern</h1><ul>
<li>有时候View Controller过于庞大会带来很多你意想不到的问题。View Controller的角色是接受用户操作然后更新views和相应的model。如今的交互变得越来越复杂化，并且还造成了很大的代码冗余。</li>
<li>交互常包括很多控件初始化，可选择性的信息输入，和一些事件，比如网络访问和状态改变。其实这种操作的生命周期是可以集成到交互对象里的。下面的例子就是讲button被按下时候的交互事件，但是把交互对象作为action的target，比如：<code>[button addTarget:self.followUserInteraction action:@selector(follow)]</code>也是很不错的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@implementation TBProfileViewController</div><div class="line"></div><div class="line">- (void)followButtonTapped:(id)sender &#123;</div><div class="line">    self.followUserInteraction = [[TBFollowUserInteraction alloc] initWithUserToFollow:self.user delegate:self];</div><div class="line">    [self.followUserInteraction follow];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)interactionCompleted:(TBFollowUserInteraction *)interaction &#123;</div><div class="line">    [self.binding updateView];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//...</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TBFollowUserInteraction : NSObject &lt;UIAlertViewDelegate&gt;</div><div class="line"></div><div class="line">- (instancetype)initWithUserToFollow:user delegate:(id&lt;InteractionDelegate&gt;)delegate &#123;</div><div class="line">    self = [super init];</div><div class="line">    if !(self) return nil;</div><div class="line">    _user = user;</div><div class="line">    _delegate = delegate;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)follow &#123;</div><div class="line">    [[[UIAlertView alloc] initWithTitle:nil</div><div class="line">                                message:@&quot;Are you sure you want to follow this user?&quot;</div><div class="line">                               delegate:self</div><div class="line">                      cancelButtonTitle:@&quot;Cancel&quot;</div><div class="line">                      otherButtonTitles:@&quot;Follow&quot;, nil] show];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123;</div><div class="line">    if  ([alertView buttonTitleAtIndex:buttonIndex] isEqual:@&quot;Follow&quot;]) &#123;</div><div class="line">        [self.user.APIGateway followWithCompletionBlock:^&#123;</div><div class="line">            [self.delegate interactionCompleted:self];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="键盘管理"><a href="#键盘管理" class="headerlink" title="键盘管理"></a>键盘管理</h1><ul>
<li>在键盘状态改变后更新视图也是一个需要考虑的点，之前有可能是放在了view controller里，但是这个功能可以很容易被移植到键盘管理对象里。当然有很多键盘管理的例子，然而，如果你觉得他们过于繁杂，可以尝试简单的版本：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@implementation TBNewPostKeyboardManager : NSObject</div><div class="line"></div><div class="line">- (instancetype)initWithTableView:(UITableView *)tableView &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) return nil;</div><div class="line">    _tableView = tableView;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)beginObservingKeyboard &#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidHide:) name:UIKeyboardDidHideNotification object:nil];</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)endObservingKeyboard &#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardDidHideNotification object:nil];</div><div class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillShowNotification object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)keyboardWillShow:(NSNotification *)note &#123;</div><div class="line">    CGRect keyboardRect = [[note.userInfo objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue];</div><div class="line"></div><div class="line">    UIEdgeInsets contentInsets = UIEdgeInsetsMake(self.tableView.contentInset.top, 0.0f, CGRectGetHeight(keyboardRect), 0.0f);</div><div class="line">    self.tableView.contentInset = contentInsets;</div><div class="line">    self.tableView.scrollIndicatorInsets = contentInsets;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)keyboardDidHide:(NSNotification *)note &#123;</div><div class="line">    UIEdgeInsets contentInset = UIEdgeInsetsMake(self.tableView.contentInset.top, 0.0f, self.oldBottomContentInset, 0.0f);</div><div class="line">    self.tableView.contentInset = contentInset;</div><div class="line">    self.tableView.scrollIndicatorInsets = contentInset;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li>你可以调用<code>-beginObservingKeyboard</code>和<code>-endObservingKeyboard</code>，从开始<code>-viewDidAppear</code>到结束<code>-viewWillDisappear</code>或者其他适合的地方。</li>
</ul>
<h1 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h1><ul>
<li>界面之间的转场正常情况下是通过<code>-pushViewController:animated:</code>。如果转场变得复杂了，那么可以考虑把这种操作代理到导航栏对象中，尤其在适用于iPhone/iPad通用的app，导航需要改变依赖于栈中的最顶端的size class。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@protocol TBUserNavigator &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)navigateToFollowersForUser:(TBUser *)user;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TBiPhoneUserNavigator : NSObject&lt;TBUserNavigator&gt;</div><div class="line"></div><div class="line">- (instancetype)initWithNavigationController:(UINavigationController *)navigationController &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) return nil;</div><div class="line">    _navigationController = navigationController;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)navigateToFollowersForUser:(TBUser *)user &#123;</div><div class="line">    TBFollowerListViewController *followerList = [[TBFollowerListViewController alloc] initWithUser:user];</div><div class="line">    [self.navigationController pushViewController:followerList animated:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TBiPadUserNavigator : NSObject&lt;TBUserNavigator&gt;</div><div class="line"></div><div class="line">- (instancetype)initWithUserViewController:(TBUserViewController *)userViewController &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) return nil;</div><div class="line">    _userViewController = userViewController;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)navigateToFollowersForUser:(TBUser *)user &#123;</div><div class="line">    TBFollowerListViewController *followerList = [[TBFollowerListViewController alloc] initWithUser:user];</div><div class="line">    self.userViewController.supplementalViewController = followerList;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这种方式凸显出了一大好处是，把大的对象拆成了很多小的模块。他们可能会被修改，重写或者是替换。相比那些复杂臃肿的view controller，你可以把导航栏设置为自定义的<code>Navigator</code>。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://thornvbear.com/2016/08/18/如何把ViewController瘦下来/" data-id="civhw175h000azxbsw11i4ic3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/UIView-Controller/">UIView Controller</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/拆分/">拆分</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/09/14/xcode8姗姗来迟/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Xcode 8.0姗姗来迟
        
      </div>
    </a>
  
  
    <a href="/2016/07/30/2016写在三周年/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">写在三周年</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/UIView-Controller/">UIView Controller</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Xcode-8-0/">Xcode 8.0</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/coding/">coding</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/github/">github</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/hexo/">hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/test/">test</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/博客/">博客</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/拆分/">拆分</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/新特性/">新特性</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/UIView-Controller/" style="font-size: 10px;">UIView Controller</a> <a href="/tags/Xcode-8-0/" style="font-size: 10px;">Xcode 8.0</a> <a href="/tags/coding/" style="font-size: 10px;">coding</a> <a href="/tags/github/" style="font-size: 10px;">github</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/test/" style="font-size: 10px;">test</a> <a href="/tags/博客/" style="font-size: 10px;">博客</a> <a href="/tags/拆分/" style="font-size: 10px;">拆分</a> <a href="/tags/新特性/" style="font-size: 10px;">新特性</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">September 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/14/xcode8姗姗来迟/">Xcode 8.0姗姗来迟</a>
          </li>
        
          <li>
            <a href="/2016/08/18/如何把ViewController瘦下来/">如何把View Controller瘦下来！</a>
          </li>
        
          <li>
            <a href="/2016/07/30/2016写在三周年/">写在三周年</a>
          </li>
        
          <li>
            <a href="/2016/07/28/Test-page/">I&#39;m a test page</a>
          </li>
        
          <li>
            <a href="/2016/07/28/新博客，新气象/">博客搬家了！</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Thon Wang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>