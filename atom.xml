<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>王绵杰的个人博客</title>
  <subtitle>STAY HUNGRY ！ STAY FOOLISH ！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-09-17T14:44:15.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Thon Wang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Xcode 8.0姗姗来迟</title>
    <link href="http://yoursite.com/2016/09/14/xcode8%E5%A7%97%E5%A7%97%E6%9D%A5%E8%BF%9F/"/>
    <id>http://yoursite.com/2016/09/14/xcode8姗姗来迟/</id>
    <published>2016-09-14T09:46:36.000Z</published>
    <updated>2016-09-17T14:44:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Xcode-8-0-版本"><a href="#Xcode-8-0-版本" class="headerlink" title="Xcode 8.0 版本"></a>Xcode 8.0 版本</h3><ul>
<li>Xcode 8.0GM版本已发布了一段时间，用于新一代的Xcode升级版本，这里普及一个知识：什么是GM版本，GM版是软件开发版本中的最终正式版的母版，不意外发现重大bug的话，GM版＝正式x.0版。Xcode 8.0正式版也于前两天正式发布，显然它是为iOS 10而生的。</li>
<li>Xcode 8.0更新提示：</li>
</ul>
<p><img src="https://dn-thornstep.qbox.me/2016-09-17xcode8.0_update_note.png" alt="Smaller image"></p>
<ul>
<li><p>首先，Xcode 8引入了Swift3.0，加入了更多新的特性，加入了支持iOS 10、watchOS 3、tvOS 10、macOS Sierra的SDK。<br>至于详细的Release Note可以查看<a href="https://developer.apple.com/library/content/releasenotes/DeveloperTools/RN-Xcode/Introduction.html" target="_blank" rel="external">https://developer.apple.com/library/content/releasenotes/DeveloperTools/RN-Xcode/Introduction.html</a></p>
</li>
<li><p>这里也没什么有用的信息，Xcode性能提升，能更好的支持XIB，增加了一些性能提示，更便于开发者进行工作开发，新加入了San Francisco Mono 编辑字体和新的主题，值得一说的是：</p>
<h3 id="1、证书管理"><a href="#1、证书管理" class="headerlink" title="1、证书管理"></a>1、证书管理</h3><p>  Xcode支持自动管理证书的功能，当然也可以自己设置。<br>  <img src="https://dn-thornstep.qbox.me/2016-09-17_sign_manage_intro.png" alt="Mou image"><br>  不过建议大家勾选这个Automatically manage signing.可以很方便的为我们管理自己的证书。</p>
<h3 id="2、xib或者storyboard的管理"><a href="#2、xib或者storyboard的管理" class="headerlink" title="2、xib或者storyboard的管理"></a>2、xib或者storyboard的管理</h3></li>
<li><p>1.xib可以更方便的查看你的布局在不同尺寸设备上的显示情况了。</p>
<p>  <img src="https://dn-thornstep.qbox.me/2016-09-17_xib_diff_device.png" alt="image"><br>  可以看到Xcode8.0把设备尺寸设置放在了布局的最下方，而右边里的Attributes Inspector里的尺寸选择取消了，并且我们可以按条件选择要查看的设备，点击<code>vary for traits</code>可以选择width或者height查看。这次可以说苹果很有良心，为这个设计点赞。</p>
</li>
<li><p>2.使用Xcode8打开xib文件后，会出现下图的提示。<br>  <img src="https://dn-thornstep.qbox.me/2016-09-17_xib_change_for_device.jpg" alt="image"></p>
<p>  大家选择Choose Device即可。之后大家会发现布局啊，frame乱了，只需要更新一下frame即可。</p>
<ul>
<li>注意：如果按上面的步骤操作后，在用Xcode7打开Xib会报一下错误</li>
<li><p>解决方法：需要删除xib里的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;capability name=&quot;documents saved in the Xcode 8 format&quot; minToolsVersion=&quot;8.0&quot;/&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>以及把&lt; document &gt;中的toolsVersion和&lt; plugIn &gt;中的version改成你正常的xib文件中的值。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3、代码注释不能用的解决办法"><a href="#3、代码注释不能用的解决办法" class="headerlink" title="3、代码注释不能用的解决办法"></a>3、代码注释不能用的解决办法</h3><ul>
<li><p>这个是因为苹果解决xcode ghost，把插件屏蔽了。</p>
<p>  解决方法</p>
<p>  打开终端，命令运行： sudo /usr/libexec/xpccachectl</p>
<p>  然后必须重启电脑后生效</p>
<p>  Xcode 8.0貌似取消了对插件的支持，因为苹果认为这会带来安全上的问题，并且提交审核会被拒绝，如果大家有什么新的解决办法请回复里告知，如果你对插件依赖性非常严重那么，可以参照<a href="http://vongloo.me/2016/09/10/Make-Your-Xcode8-Great-Again/?utm_source=tuicool&amp;utm_medium=referral&amp;sukey=3997c0719f15    15204f9d2fb0e66acbbbaaa5fd0d4849a108d51f0c9a0cdca5c0a61b68edc24f2f9423a81b60ce6e728c" target="_blank" rel="external">让你的 Xcode8 继续使用插件</a>。</p>
</li>
</ul>
<h3 id="4、iOS-10隐私权限设置"><a href="#4、iOS-10隐私权限设置" class="headerlink" title="4、iOS 10隐私权限设置"></a>4、iOS 10隐私权限设置</h3><ul>
<li>iOS 10 开始对隐私权限更加严格，如果你不设置就会直接崩溃，现在很多遇到崩溃问题了，一般解决办法都是在info.plist文件添加对应的Key-Value就可以了。</li>
</ul>
<p><img src="https://dn-thornstep.qbox.me/2016-09-17_ios10_private_setting.png" alt="image"><br>如上图显示的是部分权限设置：蓝牙使用权限，日历，相机，通讯录，健康分享，健康更新，后台一直定位，定位许可，使用时定位等权限设置。</p>
<h3 id="5、Xcode-8-运行一堆没用的logs解决办法"><a href="#5、Xcode-8-运行一堆没用的logs解决办法" class="headerlink" title="5、Xcode 8 运行一堆没用的logs解决办法"></a>5、Xcode 8 运行一堆没用的logs解决办法</h3><p><img src="https://dn-thornstep.qbox.me/2016-09-17_xcode8_print_logs.png" alt="image"><br>上图我们看到，自己新建的一个工程什么也没做直接运行打印了一堆烂七八糟的东西，我觉得这个应该是Xcode 8的问题，打印的东西也没仔细研究，看着是一些项目的状态值，如果不想每次运行都有这些东西可以在Edite Scheme——&gt;Run——&gt;Arguments里设置OS_ACTIVITY_MODE : disable如下图</p>
<p><img src="https://dn-thornstep.qbox.me/2016-09-17_lock_extra_logs.png" alt="image"></p>
<h4 id="6、iOS-10新特性"><a href="#6、iOS-10新特性" class="headerlink" title="6、iOS 10新特性"></a>6、iOS 10新特性</h4><ul>
<li>Xcode 8 是为iOS 10服务的，所以要了解iOS 10参看：<a href="https://developer.apple.com/library/content/releasenotes/General/WhatsNewIniOS/Articles/iOS10.html#//apple_ref/doc/uid/TP40017084-SW1" target="_blank" rel="external">iOS 10 苹果官方文档</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Xcode-8-0-版本&quot;&gt;&lt;a href=&quot;#Xcode-8-0-版本&quot; class=&quot;headerlink&quot; title=&quot;Xcode 8.0 版本&quot;&gt;&lt;/a&gt;Xcode 8.0 版本&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Xcode 8.0GM版本已发布了一段时间，用于
    
    </summary>
    
    
      <category term="Xcode 8.0" scheme="http://yoursite.com/tags/Xcode-8-0/"/>
    
      <category term="新特性" scheme="http://yoursite.com/tags/%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>如何把View Controller瘦下来！</title>
    <link href="http://yoursite.com/2016/08/18/%E5%A6%82%E4%BD%95%E6%8A%8AViewController%E7%98%A6%E4%B8%8B%E6%9D%A5/"/>
    <id>http://yoursite.com/2016/08/18/如何把ViewController瘦下来/</id>
    <published>2016-08-18T14:49:38.000Z</published>
    <updated>2016-08-25T15:58:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何把View-Controller瘦下来"><a href="#如何把View-Controller瘦下来" class="headerlink" title="如何把View Controller瘦下来"></a>如何把View Controller瘦下来</h1><ul>
<li>有时候View Controller由于做了太多的事情，而变得非常庞大。这里既有数据的收集，又有逻辑的处理，还有各种归属于该View Controller的控件内存分配。这里面哪些可以代理到其他模块呢？这篇博客就是探索项目的架构，目的是分离复杂的代码逻辑，让我们的代码可读性更强。</li>
<li>在View Controller里，这些职责或许是被各种 <code>#pragma mark</code> 分组实现，如果你是这样的话，那么就可以考虑把这些部分拆分到不同的文件里。</li>
</ul>
<h1 id="Data-Source"><a href="#Data-Source" class="headerlink" title="Data Source"></a>Data Source</h1><ul>
<li>Data Source的方式是一种拆离View Controller里数据显示逻辑的方式，尤其是在一些复杂的table views里，这种方式可以有效地从View Controller里分离所有cells的数据显示逻辑。</li>
<li><p>Data Source对象可以遵守<code>UITableViewDataSource</code>协议，以实现数据的显示，但是我发现使用这些对象配置cells是一件可以独立出来的逻辑，所以可以把这部分逻辑也独立出来。下面一个很简单的例子：</p>
<pre><code>@implementation TBSectionedDataSource : NSObject

- (instancetype)initWithObjects:(NSArray *)objects sectioningKey:(NSString *)sectioningKey {
    self = [super init];
    if (!self) return nil;

    [self sectionObjects:objects withKey:sectioningKey];

    return self;
}

- (void)sectionObjects:(NSArray *)objects withKey:(NSString *)sectioningKey {
    self.sectionedObjects = objects //section the objects array
}

- (NSUInteger)numberOfSections {
    return self.sectionedObjects.count;
}

- (NSUInteger)numberOfObjectsInSection:(NSUInteger)section {
    return [self.sectionedObjects[section] count];
}

- (id)objectAtIndexPath:(NSIndexPath *)indexPath {
    return self.sectionedObjects[indexPath.section][indexPath.row];
}

@end
</code></pre></li>
<li><p>这种data source的设计是为了抽象和重用，不要担心你的类仅仅在一个地方使用。从view controller里分离数据显示逻辑是一种管理懒加载的方式。特别是针对一个动态table views来说，这种方式很适合view controller来管理显示数据。</p>
</li>
<li>这种方式也可以管理你的重用逻辑。在这里可以获取服务器端的数据，从而把网络访问模块给分离出去。</li>
<li>如果你的界面是静态的话，那么你可以定制一个data source类用来专门显示这一块。在多个data source的情况下，每一个data source的子类都可以在自己的section里显示。</li>
<li>使用这种方式可以避免很多事情，把数据逻辑拆分的同时还可以把网络访问模块拆出来。</li>
</ul>
<h1 id="Standard-Composition"><a href="#Standard-Composition" class="headerlink" title="Standard Composition"></a>Standard Composition</h1><ul>
<li>这个可以理解为标准化组合，多个View Controller可以使用View Controller容器管理起来，如果你的view controller由多个逻辑单元组成，那么可以把这种复杂的逻辑拆分到多个view controller中。经验表明这种方式适合一个界面有多个table view或者是多个collection view的情况。</li>
<li><p>比如在一个界面上包含一个header和一个网格类型的视图，那么我们可以使用懒加载的方式加载这两个view controller，当系统用到的时候再去加载资源。</p>
<pre><code>- (TBHeaderViewController *)headerViewController {
    if (!_headerViewController) {
        TBHeaderViewController *headerViewController = [[TBHeaderViewController alloc] init];
          [self addChildViewController:headerViewController];
        [headerViewController didMoveToParentViewController:self];

        [self.view addSubview:headerViewController.view];

        self.headerViewController = headerViewController;
        }
        return _headerViewController;
}

- (TBGridViewController *)gridViewController {
    if (!_gridViewController) {
           TBGridViewController *gridViewController = [[TBGridViewController alloc] init];

        [self addChildViewController:gridViewController];
        [gridViewController didMoveToParentViewController:self];

        [self.view addSubview:gridViewController.view];

        self.gridViewController = gridViewController;
    }
    return _gridViewController;
}

- (void)viewDidLayoutSubviews {
    [super viewDidLayoutSubviews];

    CGRect workingRect = self.view.bounds;

    CGRect headerRect = CGRectZero, gridRect = CGRectZero;
    CGRectDivide(workingRect, &amp;headerRect, &amp;gridRect, 44, CGRectMinYEdge);

    self.headerViewController.view.frame = tagHeaderRect;
    self.gridViewController.view.frame = hotSongsGridRect;
}
</code></pre></li>
<li><p>在结果子视图里，其包含的每个collection view，都展示统一的数据类型，这样更便于管理和修改。</p>
<h1 id="Smarter-Views"><a href="#Smarter-Views" class="headerlink" title="Smarter Views"></a>Smarter Views</h1></li>
<li><p>如果你是在view controller类初始化你所有的子视图的话，那么你应该考虑使用更适合自己的View。UIViewController默认使用UIView，不过同样你可以自定义View实现重写。使用<code>-loadView</code>来达到这种效果，在这里你只需要把自定义的View设置给<code>self.view</code>即可。</p>
<pre><code>@implementation TBProfileViewController

- (void)loadView {
    self.view = [[TBProfileView alloc] init];
}

//...

@end

@implementation TBProfileView : NSObject

- (UILabel *)nameLabel {
    if (!_nameLabel) {
        UILabel *nameLabel = [[UILabel alloc] init];
        //configure font, color, etc
        [self addSubview:nameLabel];
            self.nameLabel = nameLabel;
    }
    return _nameLabel;
}

- (UIImageView *)avatarImageView {
    if (!_avatarImageView) {
        UIImageView * avatarImageView = [UIImageView new];
        [self addSubview:avatarImageView];
        self.avatarImageView = avatarImageView;
    }
    return _avatarImageView
}

- (void)layoutSubviews {
    //perform layout
}

@end
</code></pre><h1 id="Presenter"><a href="#Presenter" class="headerlink" title="Presenter"></a>Presenter</h1></li>
<li>Presenter（一系列get方法）是从Model中获取数据并提供给View层，Presenter还负责处理后台任务</li>
<li>主导器一般包含着model对象，这里的model是用来展示的，所以属性都是暴露出来的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@implementation TBUserPresenter : NSObject</div><div class="line"></div><div class="line">- (instancetype)initWithUser:(TBUser *)user &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) return nil;</div><div class="line">    _user = user;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)name &#123;</div><div class="line">    return self.user.name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)followerCountString &#123;</div><div class="line">    if (self.user.followerCount == 0) &#123;</div><div class="line">        return @&quot;&quot;;</div><div class="line">    &#125;</div><div class="line">    return [NSString stringWithFormat:@&quot;%@ followers&quot;, [NSNumberFormatter localizedStringFromNumber:@(_user.followerCount) numberStyle:NSNumberFormatterDecimalStyle]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSString *)followersString &#123;</div><div class="line">    NSMutableString *followersString = [@&quot;Followed by &quot; mutableCopy];</div><div class="line">    [followersString appendString:[self.class.arrayFormatter stringFromArray:[self.user.topFollowers valueForKey:@&quot;name&quot;]];</div><div class="line">    return followersString;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (TTTArrayFormatter*) arrayFormatter &#123;</div><div class="line">    static TTTArrayFormatter *_arrayFormatter;</div><div class="line">    static dispatch_once_t onceToken;</div><div class="line">    dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">        _arrayFormatter = [[TTTArrayFormatter alloc] init];</div><div class="line">        _arrayFormatter.usesAbbreviatedConjunction = YES;</div><div class="line">    &#125;);</div><div class="line">    return _arrayFormatter;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li>需要注意的一点是，model对象本身是不暴露出去的。Presenter作为model的看门人，保证了view controller不用避开主逻辑服务，而可以直接访问model层。这种架构减少了依赖性，由于 <code>TBUser</code> 的存在，使得model接触的类比较少，因此如果它改变，则牵涉的逻辑比较少。</li>
</ul>
<h1 id="Binding-pattern"><a href="#Binding-pattern" class="headerlink" title="Binding pattern"></a>Binding pattern</h1><ul>
<li>在形式上，这种可以看做<code>-configureView</code>。当数据层发生改变的时候捆绑形式就会更新view。Cocoa本身就适合这个，因为KVO可以检测到model层的变动，而KVC可以从model层读取数据然后赋给view，两者实现完美结合。第三方库Reactive Cocoa也是采用了这种方式，但它有点太庞大。</li>
<li>这种方式与主导器结合起来效果非常好，一个创建对象来传递值，而另一个去接受然后显示到view上。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">@implementation TBProfileBinding : NSObject</div><div class="line"></div><div class="line">- (instancetype)initWithView:(TBProfileView *)view presenter:(TBUserPresenter *)presenter &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) return nil;</div><div class="line">    _view = view;</div><div class="line">    _presenter = presenter;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (NSDictionary *)bindings &#123;</div><div class="line">    return @&#123;</div><div class="line">              @&quot;name&quot;: @&quot;nameLabel.text&quot;,</div><div class="line">              @&quot;followerCountString&quot;: @&quot;followerCountLabel.text&quot;,</div><div class="line">            &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)updateView &#123;</div><div class="line">    [self.bindings enumerateKeysAndObjectsUsingBlock:^(id presenterKeyPath, id viewKeyPath, BOOL *stop) &#123;</div><div class="line">        id newValue = [self.presenter valueForKeyPath:presenterKeyPath];</div><div class="line">        [self.view setObject:newvalue forKeyPath:viewKeyPath];</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<h1 id="interaction-pattern"><a href="#interaction-pattern" class="headerlink" title="interaction pattern"></a>interaction pattern</h1><ul>
<li>有时候View Controller过于庞大会带来很多你意想不到的问题。View Controller的角色是接受用户操作然后更新views和相应的model。如今的交互变得越来越复杂化，并且还造成了很大的代码冗余。</li>
<li>交互常包括很多控件初始化，可选择性的信息输入，和一些事件，比如网络访问和状态改变。其实这种操作的生命周期是可以集成到交互对象里的。下面的例子就是讲button被按下时候的交互事件，但是把交互对象作为action的target，比如：<code>[button addTarget:self.followUserInteraction action:@selector(follow)]</code>也是很不错的。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@implementation TBProfileViewController</div><div class="line"></div><div class="line">- (void)followButtonTapped:(id)sender &#123;</div><div class="line">    self.followUserInteraction = [[TBFollowUserInteraction alloc] initWithUserToFollow:self.user delegate:self];</div><div class="line">    [self.followUserInteraction follow];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)interactionCompleted:(TBFollowUserInteraction *)interaction &#123;</div><div class="line">    [self.binding updateView];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//...</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TBFollowUserInteraction : NSObject &lt;UIAlertViewDelegate&gt;</div><div class="line"></div><div class="line">- (instancetype)initWithUserToFollow:user delegate:(id&lt;InteractionDelegate&gt;)delegate &#123;</div><div class="line">    self = [super init];</div><div class="line">    if !(self) return nil;</div><div class="line">    _user = user;</div><div class="line">    _delegate = delegate;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)follow &#123;</div><div class="line">    [[[UIAlertView alloc] initWithTitle:nil</div><div class="line">                                message:@&quot;Are you sure you want to follow this user?&quot;</div><div class="line">                               delegate:self</div><div class="line">                      cancelButtonTitle:@&quot;Cancel&quot;</div><div class="line">                      otherButtonTitles:@&quot;Follow&quot;, nil] show];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123;</div><div class="line">    if  ([alertView buttonTitleAtIndex:buttonIndex] isEqual:@&quot;Follow&quot;]) &#123;</div><div class="line">        [self.user.APIGateway followWithCompletionBlock:^&#123;</div><div class="line">            [self.delegate interactionCompleted:self];</div><div class="line">        &#125;];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="键盘管理"><a href="#键盘管理" class="headerlink" title="键盘管理"></a>键盘管理</h1><ul>
<li>在键盘状态改变后更新视图也是一个需要考虑的点，之前有可能是放在了view controller里，但是这个功能可以很容易被移植到键盘管理对象里。当然有很多键盘管理的例子，然而，如果你觉得他们过于繁杂，可以尝试简单的版本：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@implementation TBNewPostKeyboardManager : NSObject</div><div class="line"></div><div class="line">- (instancetype)initWithTableView:(UITableView *)tableView &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) return nil;</div><div class="line">    _tableView = tableView;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)beginObservingKeyboard &#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidHide:) name:UIKeyboardDidHideNotification object:nil];</div><div class="line">    [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)endObservingKeyboard &#123;</div><div class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardDidHideNotification object:nil];</div><div class="line">    [[NSNotificationCenter defaultCenter] removeObserver:self name:UIKeyboardWillShowNotification object:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)keyboardWillShow:(NSNotification *)note &#123;</div><div class="line">    CGRect keyboardRect = [[note.userInfo objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue];</div><div class="line"></div><div class="line">    UIEdgeInsets contentInsets = UIEdgeInsetsMake(self.tableView.contentInset.top, 0.0f, CGRectGetHeight(keyboardRect), 0.0f);</div><div class="line">    self.tableView.contentInset = contentInsets;</div><div class="line">    self.tableView.scrollIndicatorInsets = contentInsets;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)keyboardDidHide:(NSNotification *)note &#123;</div><div class="line">    UIEdgeInsets contentInset = UIEdgeInsetsMake(self.tableView.contentInset.top, 0.0f, self.oldBottomContentInset, 0.0f);</div><div class="line">    self.tableView.contentInset = contentInset;</div><div class="line">    self.tableView.scrollIndicatorInsets = contentInset;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<ul>
<li>你可以调用<code>-beginObservingKeyboard</code>和<code>-endObservingKeyboard</code>，从开始<code>-viewDidAppear</code>到结束<code>-viewWillDisappear</code>或者其他适合的地方。</li>
</ul>
<h1 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h1><ul>
<li>界面之间的转场正常情况下是通过<code>-pushViewController:animated:</code>。如果转场变得复杂了，那么可以考虑把这种操作代理到导航栏对象中，尤其在适用于iPhone/iPad通用的app，导航需要改变依赖于栈中的最顶端的size class。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">@protocol TBUserNavigator &lt;NSObject&gt;</div><div class="line"></div><div class="line">- (void)navigateToFollowersForUser:(TBUser *)user;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TBiPhoneUserNavigator : NSObject&lt;TBUserNavigator&gt;</div><div class="line"></div><div class="line">- (instancetype)initWithNavigationController:(UINavigationController *)navigationController &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) return nil;</div><div class="line">    _navigationController = navigationController;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)navigateToFollowersForUser:(TBUser *)user &#123;</div><div class="line">    TBFollowerListViewController *followerList = [[TBFollowerListViewController alloc] initWithUser:user];</div><div class="line">    [self.navigationController pushViewController:followerList animated:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation TBiPadUserNavigator : NSObject&lt;TBUserNavigator&gt;</div><div class="line"></div><div class="line">- (instancetype)initWithUserViewController:(TBUserViewController *)userViewController &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (!self) return nil;</div><div class="line">    _userViewController = userViewController;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)navigateToFollowersForUser:(TBUser *)user &#123;</div><div class="line">    TBFollowerListViewController *followerList = [[TBFollowerListViewController alloc] initWithUser:user];</div><div class="line">    self.userViewController.supplementalViewController = followerList;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>这种方式凸显出了一大好处是，把大的对象拆成了很多小的模块。他们可能会被修改，重写或者是替换。相比那些复杂臃肿的view controller，你可以把导航栏设置为自定义的<code>Navigator</code>。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;如何把View-Controller瘦下来&quot;&gt;&lt;a href=&quot;#如何把View-Controller瘦下来&quot; class=&quot;headerlink&quot; title=&quot;如何把View Controller瘦下来&quot;&gt;&lt;/a&gt;如何把View Controller瘦下来&lt;/
    
    </summary>
    
    
      <category term="UIView Controller" scheme="http://yoursite.com/tags/UIView-Controller/"/>
    
      <category term="拆分" scheme="http://yoursite.com/tags/%E6%8B%86%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>写在三周年</title>
    <link href="http://yoursite.com/2016/07/30/2016%E5%86%99%E5%9C%A8%E4%B8%89%E5%91%A8%E5%B9%B4/"/>
    <id>http://yoursite.com/2016/07/30/2016写在三周年/</id>
    <published>2016-07-30T10:00:09.000Z</published>
    <updated>2016-08-01T17:19:26.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>I&#39;m a test page</title>
    <link href="http://yoursite.com/2016/07/28/Test-page/"/>
    <id>http://yoursite.com/2016/07/28/Test-page/</id>
    <published>2016-07-28T09:39:13.000Z</published>
    <updated>2016-08-01T14:53:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>博客搬家了！</title>
    <link href="http://yoursite.com/2016/07/28/%E6%96%B0%E5%8D%9A%E5%AE%A2%EF%BC%8C%E6%96%B0%E6%B0%94%E8%B1%A1/"/>
    <id>http://yoursite.com/2016/07/28/新博客，新气象/</id>
    <published>2016-07-28T09:39:13.000Z</published>
    <updated>2016-08-03T14:36:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="我的博客之路"><a href="#我的博客之路" class="headerlink" title="我的博客之路"></a>我的博客之路</h2><p><img align="center" src="https://dn-thornstep.qbox.me/2016-07-30_blog_image.png"></p>
<h3 id="CSDN"><a href="#CSDN" class="headerlink" title="CSDN"></a>CSDN</h3><p>如今进入互联网这一行，如果没有自己的博客你都不好意思跟人家聊技术，我在3、4年就开始在CSDN上记录自己的学习过程，那时候之所以在CSDN上建博客，一来是因为方便，再者是没有技术要求。然而久而久之你会发现，这东西已经无法满足我们的要求，丫每次打开博客的时候都下决心要自定义自己的博客，于是乎就有了基于Octopress的博客。<br><a href="http://blog.csdn.net/u014783027" target="_blank" rel="external">CSDN博客</a></p>
<h3 id="Octopress"><a href="#Octopress" class="headerlink" title="Octopress"></a>Octopress</h3><p>那是去年的第一场雪，比前年来的稍晚一些；我在自己的mac上键入疾飞，在克服重重困难之后终于在<a href="https://github.com/" target="_blank" rel="external">github</a>上搭建了属于自己的博客。此博客用了一年之久，然而又久而久之，丫又满足不了我们的要求了。一是因为人懒了，好久没更新了，更重要是提交更新巨慢啊，<code>rake preview</code>之后，喝了一杯咖啡你会发现还有百分之十未完成。这是由于Octopress是基于Ruby的，生成博客文章的速度非常慢，于是我就查找到了代替它的东西<a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>。</p>
<h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>使用Hexo的原因：</p>
<ul>
<li>Hexo和Octopress都是生成静态文件，可以很方便的托管到github和coding上</li>
<li>Hexo是基于Node的，而Node的速度是非常快的</li>
<li>Hexo目前在github上的stars已经超过Octopress，更多的人在维护Hexo</li>
</ul>
<p>配置Hexo的大致过程以及自己踩过的坑：</p>
<h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>要安装Hexo首先要安装<a href="https://www.npmjs.com/" target="_blank" rel="external">npm</a>:</p>
<p><strong>入坑1：</strong></p>
<p>当你安装npm的时候会提示你本地没有安装node,然后你去费劲周折安装node，回来再安装npm，觉得这次可以了吧。然后你会发现装不动啊，丫去查资料发现镜像是国外的，又是背墙的悲剧。换<a href="http://npm.taobao.org/" target="_blank" rel="external">淘宝镜像</a>,然后你终于发现在中国还是国产的好（当然核心还是国外的啊）！不过，最近发现NodeJs的安装包默认安装npm，这可方便了很多。</p>
<p>现在如下命令安装 Hexo：</p>
<pre><code>npm install -g hexo-cli
</code></pre><p>如果报用户权限不够就试试sudo，如果提示各种ERR的话就试试：</p>
<pre><code>npm install hexo --no-optional
</code></pre><p>实在不行，重新安装npm。</p>
<h4 id="创建一个新的博客"><a href="#创建一个新的博客" class="headerlink" title="创建一个新的博客"></a>创建一个新的博客</h4><p>接着我们创建一个新的博客目录：</p>
<pre><code>$ hexo init myBlogFolder #本地建文件夹
$ cd myBlogFolder
$ npm install
</code></pre><p>以上命令完成后，会在目标目录生成以下的目录结构：</p>
<pre><code>.
├── _config.yml
├── package.json
├── scaffolds
├── source
|   └── _posts
└── themes
</code></pre><p>之前的hexo会默认在source建很多文件夹，不过最近版的hexo只有一个_posts文件夹，其他需要自己创建。<br>可以看到，hexo的目录非常简单：</p>
<ul>
<li>_config.yml 是博客的配置文件，里面可以配置你的Title，签名，头像等等（ps:配置文件有Key: value的格式，并且冒号后必须有空格）</li>
<li>scaffolds 是博客文章模板。</li>
<li>source 是博客文章目录，你可以在这里添加标签、关于等文件夹便于管理。</li>
<li>themes 存放主题风格文件，默认是landscape，我个人使用的是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">Next</a>。</li>
</ul>
<h4 id="OK！测试一下："><a href="#OK！测试一下：" class="headerlink" title="OK！测试一下："></a>OK！测试一下：</h4><p>生成博客配置文件</p>
<pre><code>hexo g
</code></pre><p>发布到本地服务器</p>
<pre><code>hexo s
</code></pre><p>访问：<code>localhost:4000</code><br>然后你会看到很朴素的博客就诞生了。</p>
<h4 id="发布到github和coding"><a href="#发布到github和coding" class="headerlink" title="发布到github和coding"></a>发布到github和coding</h4><p>根目录的_config.yml中找到：</p>
<pre><code>deploy:
    type: git
    repo:
    coding: https://git.coding.net/yourcoding/yourcoding.git,coding-pages
    github: https://github.com/yourgithub/yourgithub.github.io.git,master
</code></pre><p><strong>入坑2:</strong></p>
<p>在配置coding的时候，一定要放在coding-pages的分支，不要放在master，因为coding的pages功能默认在coding-pages分支上，当时我就是错设置为master，导致一直404；</p>
<p><strong>入坑3:</strong></p>
<p>在github建repository的时候，github默认每个用户只能建一个pages静态链接库，并且在创建repository时候加上<code>.github.io</code></p>
<h4 id="绑定域名"><a href="#绑定域名" class="headerlink" title="绑定域名"></a>绑定域名</h4><p>如果有需要可以购买属于自己的域名，设置解析域名，海外绑定github的地址，默认绑定coding的地址，这样就可以国内访问coding，国外访问github了。这里如何把github和coding绑定到自己的域名就不说了，网上有很多这方面的资料。</p>
<h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><p>记录学习与生活，希望自己在这一块净土，耕耘并记录自己的未来。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;我的博客之路&quot;&gt;&lt;a href=&quot;#我的博客之路&quot; class=&quot;headerlink&quot; title=&quot;我的博客之路&quot;&gt;&lt;/a&gt;我的博客之路&lt;/h2&gt;&lt;p&gt;&lt;img align=&quot;center&quot; src=&quot;https://dn-thornstep.qbox.me/
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="coding" scheme="http://yoursite.com/tags/coding/"/>
    
  </entry>
  
</feed>
